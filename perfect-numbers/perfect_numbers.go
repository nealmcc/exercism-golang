package perfect

import (
	"errors"
)

type Classification int

const (
	ClassificationDeficient Classification = iota
	ClassificationPerfect
	ClassificationAbundant
)

var ErrOnlyPositive = errors.New("only positive numbers can be classified")

func Classify(n int64) (Classification, error) {
	if n <= 0 {
		return 0, ErrOnlyPositive
	}

	sum, exceeded := sumToLimit(lazyFactor(n), 2*n)
	switch {
	case exceeded:
		return ClassificationAbundant, nil
	case sum == 2*n:
		return ClassificationPerfect, nil
	default:
		return ClassificationDeficient, nil
	}
}

// sumToLimit adds up the numbers generated by g, stopping either when
// when the limit is exceeded, or the generator runs out of numbers.
func sumToLimit(gen generator, limit int64) (sum int64, exceeded bool) {
	n, ok := gen()
	for ok {
		sum += n
		if sum > limit {
			exceeded = true
			return
		}
		n, ok = gen()
	}
	return
}

type generator func() (n int64, ok bool)

// lazyFactor returns a generator function.
// Each call to the generator will return another factor and a boolean flag to
// indicate that the call succeeded.
// If there are no more factors, then the function will return 0 and false.
func lazyFactor(dividend int64) generator {
	var (
		i int64 = 1 // the iterator for our loop
		b int64 = 0 // the 'second' factor from each pair as we find them
	)

	return func() (a int64, ok bool) {
		if b != 0 {
			// we have a factor saved from the previous call:
			a, b, ok = b, 0, true
			return
		}
		// find the next factor pair
		for i*i <= dividend {
			if dividend%i == 0 {
				// save the second factor for the next call
				a, b, ok = i, dividend/i, true
				if a == b {
					// don't repeat the same factor twice
					b = 0
				}
				i++
				return
			}
			i++
		}
		return
	}
}
